<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Gears: Optparse Tutorial</title>
<title>Optparse Tutorial</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="index.html"><img alt="Logo" src="gears.png"/></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('optparse_tut.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Optparse Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#basics">Basics</a></li>
<li class="level1"><a href="#a_little_involved">A Little More Involved</a></li>
<li class="level1"><a href="#positional_args">Introducing Positional Arguments</a></li>
<li class="level1"><a href="#types_value">Different Types of Values</a></li>
<li class="level1"><a href="#advanced_usage">Advanced Usage</a><ul><li class="level2"><a href="#using_subcommands">Using Subcommands</a></li>
<li class="level2"><a href="#custom_parser">Custom Parsers and Actions</a></li>
<li class="level2"><a href="#custom_eh_and_f">Custom Error Handling and Formatting</a><ul><li class="level3"><a href="#custom_eh">Custom Error Handling</a></li>
<li class="level3"><a href="#custom_format">Custom Formatting</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The following sections will walk you through the using the optparse module along with things such as customisation. All code snippets are assumed to be under the namespace alias <code>opt</code>. You can get this behaviour by doing <code>namespace opt = gears::optparse</code>. All examples are also assumed to be compiled into an executable called <code>dev</code>.</p>
<h1><a class="anchor" id="basics"></a>
Basics</h1>
<p>We begin using the module with an incredibly simple example. This example just declares a parser and parses the arguments.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser;</div>
<div class="line">    parser.parse(argv, argv + argc);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When this is executed, you'll notice that all the errors are handled gracefully for you and the help message is automatically provided for you.</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">$ ./dev --help</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h, --help         shows <span class="keyword">this</span> message and exits</div>
<div class="line">$ ./dev --test</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: unrecognised option <span class="stringliteral">&#39;--test&#39;</span></div>
</div><!-- fragment --></div><p>Command line parsing tends to involve multiple options and values. As you may have noticed earlier, this module uses the POSIX/Unix standards for passing command line options. The rules are simple:</p>
<ul>
<li>Long options start with <code>--</code>.</li>
<li>Short options start with <code>-</code>.</li>
<li>Values can be specified through a space or an equal sign for key-value pairs.</li>
<li>Short options can be concatenated (this will be shown later).</li>
<li>A sole <code>--</code> delimits positional arguments and command line options (this will be shown later).</li>
</ul>
<p>Currently, there's a big problem: our program doesn't do anything!</p>
<h1><a class="anchor" id="a_little_involved"></a>
A Little More Involved</h1>
<p>For this example, we'll add two command line options. One that takes in a value, and another that doesn't.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;quiet&quot;</span>, <span class="stringliteral">&quot;print minimal info&quot;</span> },</div>
<div class="line">        { <span class="stringliteral">&quot;compression&quot;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;sets compression level&quot;</span>, opt::value&lt;int&gt;() }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="stringliteral">&quot;compression&quot;</span>)) {</div>
<div class="line">        <span class="keywordflow">if</span>(!args.options.is_active(<span class="stringliteral">&quot;quiet&quot;</span>)) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;The compression level is: &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; args.options.get&lt;<span class="keywordtype">int</span>&gt;(<span class="charliteral">&#39;c&#39;</span>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Compression is not set\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And here's running it:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">Compression is not <span class="keyword">set</span></div>
<div class="line">$ ./dev -h</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h, --help          shows <span class="keyword">this</span> message and exits</div>
<div class="line">        --quiet         print minimal info</div>
<div class="line">    -c, --compression   sets compression level</div>
<div class="line">$ ./dev -c 10</div>
<div class="line">The compression level is: 10</div>
<div class="line">$ ./dev --quiet --compression=20</div>
<div class="line">20</div>
<div class="line">$ ./dev --compression</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: option <span class="stringliteral">&#39;--compression&#39;</span> requires an argument</div>
</div><!-- fragment --></div><p>A couple things to note:</p>
<ul>
<li>The results of the parsing is sent to an <code>arguments</code> struct.</li>
<li>You can access the options by going to its options member.</li>
<li>You query if the option is currently active through the <code>is_active</code> member function.</li>
<li>You can ask for an option through its short or long name.</li>
<li>An error is shown if an argument is not found.</li>
</ul>
<h1><a class="anchor" id="positional_args"></a>
Introducing Positional Arguments</h1>
<p>For this example, we'll introduce a positional argument and multiplies the number by four. If a verbose flag is set, then it'll print a sentence explaining the computation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;verbose&quot;</span>, <span class="stringliteral">&quot;prints the computation&quot;</span> }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    parser.usage = <span class="stringliteral">&quot;[option] number&quot;</span>;</div>
<div class="line">    parser.description = <span class="stringliteral">&quot;Multiplies a number by four&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.positional.empty()) {</div>
<div class="line">        parser.error(<span class="stringliteral">&quot;no number given&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> number = std::stoi(args.positional.front());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="stringliteral">&quot; * 4 = &quot;</span> &lt;&lt; number * 4 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; number * 4 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And of course, running it shows this:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">usage: ./dev [option] number</div>
<div class="line">./dev: error: no number given</div>
<div class="line">$ ./dev -h</div>
<div class="line">usage: ./dev [option] number</div>
<div class="line"></div>
<div class="line">Multiplies a number by four</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h, --help            shows <span class="keyword">this</span> message and exits</div>
<div class="line">        --verbose         prints the computation</div>
<div class="line">$ ./dev 10</div>
<div class="line">40</div>
<div class="line">$ ./dev --verbose 19</div>
<div class="line">19 * 4 = 76</div>
<div class="line">$ ./dev 19 --verbose</div>
<div class="line">76</div>
</div><!-- fragment --></div><p>A couple notes:</p>
<ul>
<li>The order of positional and optional arguments matter</li>
<li>Positional arguments are stored under the positional member as strings.</li>
</ul>
<p>As you can see, you can modify the output of the <code>--help</code> message through the usage and description members. Another way to modify the <code>--help</code> message is through the <code>epilogue</code> member which would be the message printed at the end of the <code>--help</code> message.</p>
<p>Working with positional arguments that expect a specific type other than string can be a little annoying. In the next section, we'll talk about the different kinds of values we can store in an option.</p>
<h1><a class="anchor" id="types_value"></a>
Different Types of Values</h1>
<p>This example builds on the other example by automatically handling the conversion of the positional arguments by using an optional argument instead.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;verbose&quot;</span>, <span class="stringliteral">&quot;prints the computation&quot;</span> },</div>
<div class="line">        { <span class="stringliteral">&quot;numbers&quot;</span>, <span class="stringliteral">&quot;the numbers to compute&quot;</span>, opt::list&lt;std::vector&lt;int&gt;&gt;(2), opt::trait::required },</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    parser.description = <span class="stringliteral">&quot;Multiplies two numbers together&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; numbers = args.options.get&lt;std::vector&lt;int&gt;&gt;(<span class="stringliteral">&quot;numbers&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; numbers[0] &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; numbers[1] &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; numbers[0] * numbers[1] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; numbers[0] * numbers[1] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Introduced in this example is the trait enum which is used as a bit flag that is used to modify the behaviour of the option. In this case, the trait given is that the option is required to continue.</p>
<p>Running the the program gives the following output:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: missing required option <span class="stringliteral">&#39;--numbers&#39;</span></div>
<div class="line">$ ./dev --numbers 19 20</div>
<div class="line">380</div>
<div class="line">$ ./dev --verbose --numbers 19 20</div>
<div class="line">19 * 20 = 380</div>
<div class="line">$ ./dev --verbose --numbers</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: option <span class="stringliteral">&#39;--numbers&#39;</span> requires 2 arguments</div>
</div><!-- fragment --></div><p>Other types of values can be seen in this demonstrative example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <span class="keywordtype">int</span> stuff = 0;</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;modify&quot;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="stringliteral">&quot;modifies a variable in C++&quot;</span>, opt::bind_to(stuff) },</div>
<div class="line">        { <span class="stringliteral">&quot;const&quot;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;always returns 42&quot;</span>, opt::constant(42) },</div>
<div class="line">        { <span class="charliteral">&#39;I&#39;</span>, <span class="stringliteral">&quot;include directories&quot;</span>, opt::compose&lt;std::vector&lt;std::string&gt;&gt;() }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="charliteral">&#39;I&#39;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;include directories:\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp;&amp; i : args.options.get&lt;std::vector&lt;std::string&gt;&gt;(<span class="charliteral">&#39;I&#39;</span>)) {</div>
<div class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;stuff variable: &quot;</span> &lt;&lt; stuff &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="charliteral">&#39;c&#39;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;constant: &quot;</span> &lt;&lt; args.options.get&lt;<span class="keywordtype">int</span>&gt;(<span class="charliteral">&#39;c&#39;</span>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And the output is as follows:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">stuff variable: 0</div>
<div class="line">$ ./dev -m 10 -c</div>
<div class="line">stuff variable: 10</div>
<div class="line"><a class="code" href="structgears_1_1optparse_1_1typed__value.html#abcb16808fae424d82f6bd08fa91e073b" title="Returns a typed_value that returns a constant value.">constant</a>: 42</div>
<div class="line">$ ./dev -cm 10</div>
<div class="line">stuff variable: 10</div>
<div class="line"><a class="code" href="structgears_1_1optparse_1_1typed__value.html#abcb16808fae424d82f6bd08fa91e073b" title="Returns a typed_value that returns a constant value.">constant</a>: 42</div>
<div class="line">$ ./dev -I <span class="stringliteral">&quot;/usr/include&quot;</span> -cm 42 -I <span class="stringliteral">&quot;.&quot;</span></div>
<div class="line">include directories:</div>
<div class="line">/usr/include</div>
<div class="line">.</div>
<div class="line">stuff variable: 42</div>
<div class="line"><a class="code" href="structgears_1_1optparse_1_1typed__value.html#abcb16808fae424d82f6bd08fa91e073b" title="Returns a typed_value that returns a constant value.">constant</a>: 42</div>
</div><!-- fragment --></div><h1><a class="anchor" id="advanced_usage"></a>
Advanced Usage</h1>
<p>This section details more advanced usage including subcommands, custom error handling, and using custom parsers to further customise optparse to your liking.</p>
<h2><a class="anchor" id="using_subcommands"></a>
Using Subcommands</h2>
<p>The optparse module provides support for subcommands that allow the usage of command line interfaces similar to those found in <code>git</code>, <code>svn</code>, and <code>hg</code>. Examples of subcommands include things such as <code>git add</code>, <code>git commit</code>, and <code>git checkout</code>, you get the message. Subcommands are very easy to register, just look at the following example which implements a basic two command calculator to do some arithmetic:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser;</div>
<div class="line">    <span class="keywordtype">int</span> lhs = 0;</div>
<div class="line">    <span class="keywordtype">int</span> rhs = 0;</div>
<div class="line">    parser.usage = <span class="stringliteral">&quot;&lt;calculation&gt; [options...]&quot;</span>;</div>
<div class="line">    parser.description = <span class="stringliteral">&quot;Calculates a binary expression through subcommands.&quot;</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    opt::option_set common_options = {</div>
<div class="line">        { <span class="stringliteral">&quot;left&quot;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="stringliteral">&quot;the left hand side of the expression (default: 0)&quot;</span>, opt::bind_to(lhs) },</div>
<div class="line">        { <span class="stringliteral">&quot;right&quot;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;the right hand side of the expression (default: 0)&quot;</span>, opt::bind_to(rhs) },</div>
<div class="line">        { <span class="stringliteral">&quot;verbose&quot;</span>, <span class="stringliteral">&quot;shows verbose calculation&quot;</span> }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    parser.add_subcommand({ <span class="stringliteral">&quot;add&quot;</span>, <span class="stringliteral">&quot;adds two numbers&quot;</span>, common_options });</div>
<div class="line">    parser.add_subcommand({ <span class="stringliteral">&quot;subtract&quot;</span>, <span class="stringliteral">&quot;multiplies two numbers&quot;</span>, common_options });</div>
<div class="line">    parser.add_subcommand({ <span class="stringliteral">&quot;multiply&quot;</span>, <span class="stringliteral">&quot;subtracts two numbers&quot;</span>, common_options });</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line">    <span class="keywordtype">bool</span> is_verbose = args.options.is_active(<span class="stringliteral">&quot;verbose&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.subcommand.empty()) {</div>
<div class="line">        parser.error(<span class="stringliteral">&quot;no calculation given&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.subcommand == <span class="stringliteral">&quot;add&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">if</span>(is_verbose) {</div>
<div class="line">            std::cout &lt;&lt; lhs &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; rhs &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; lhs + rhs &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(args.subcommand == <span class="stringliteral">&quot;subtract&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">if</span>(is_verbose) {</div>
<div class="line">            std::cout &lt;&lt; lhs &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; rhs &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; lhs - rhs &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(args.subcommand == <span class="stringliteral">&quot;multiply&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">if</span>(is_verbose) {</div>
<div class="line">            std::cout &lt;&lt; lhs &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; rhs &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; lhs * rhs &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running the executable gives us the following:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">usage: ./dev &lt;calculation&gt; [options...]</div>
<div class="line">./dev: error: no calculation given</div>
<div class="line">$ ./dev -h</div>
<div class="line">usage: ./dev &lt;calculation&gt; [options...]</div>
<div class="line"></div>
<div class="line">subcommands</div>
<div class="line">    add                     adds two numbers</div>
<div class="line">    subtract                <a class="code" href="group__functional__objects.html#gac5484073a5a431c37c00631f4504cd7c" title="Function object performing multiplication.">multiplies</a> two numbers</div>
<div class="line">    multiply                subtracts two numbers</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h, --help         shows <span class="keyword">this</span> message and exits</div>
<div class="line">$ ./dev multiply -h</div>
<div class="line">usage: ./dev multiply [options..]</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h, --help            shows <span class="keyword">this</span> message and exits</div>
<div class="line">    -l, --<a class="code" href="group__string.html#gabb9831335ab48a15377e120039532ad5" title="Returns the left portion of a string.">left</a>            the <a class="code" href="group__string.html#gabb9831335ab48a15377e120039532ad5" title="Returns the left portion of a string.">left</a> hand side of the expression (<span class="keywordflow">default</span>: 0)</div>
<div class="line">    -r, --<a class="code" href="group__string.html#ga72d9013326acd8e20e2ac9ade5d77e99" title="Returns the right portion of a string.">right</a>           the <a class="code" href="group__string.html#ga72d9013326acd8e20e2ac9ade5d77e99" title="Returns the right portion of a string.">right</a> hand side of the expression (<span class="keywordflow">default</span>: 0)</div>
<div class="line">        --verbose         shows verbose calculation</div>
<div class="line">$ ./dev multiply -l 10 -r 20</div>
<div class="line">200</div>
<div class="line">$ ./dev add -l 30 -r 40 --verbose</div>
<div class="line">30 + 40 = 70</div>
<div class="line">$ ./dev subtract -l 50 -r 45</div>
<div class="line">5</div>
</div><!-- fragment --></div><p>There are a lot of new things shown here. Some important things to notice:</p>
<ul>
<li>Every subcommand has its own usage message that can be customised.</li>
<li>Every subcommand has its own list of options.</li>
<li>Every subcommand is printed through the main program's <code>--help</code> message.</li>
<li>The active subcommand name can be retrieved through the <code>subcommand</code> member.</li>
<li>The options member automatically updates to the active subcommand.</li>
<li>Options can be stored in an option_set class and shared.</li>
</ul>
<p>The API for subcommands is simple enough to not complicate the main querying code.</p>
<h2><a class="anchor" id="custom_parser"></a>
Custom Parsers and Actions</h2>
<p>The optparse module parses things based on something called an action. An action takes in a key and a value and then returns the result of parsing. The actions are typically abstracted away when using the factory functions such as <code>opt::bind_to</code>, <code>opt::value</code>, and <code>opt::list</code>, etc. However, in order to create something similar, it doesn't take much effort. A factory function was made to ease into the creation of custom actions named <code>opt::custom</code>. Note, however, that almost all the factory functions take in an action as a parameter. An action can be any type of callable as long as it meets the signature of <code>T(const std::string&amp;, const std::string&amp;)</code>. The type of <code>T</code> is the one provided when creating a value. So in <code>opt::value&lt;int&gt;()</code>, the type of <code>T</code> is <code>int</code>.</p>
<p>The following example shows how to parse a complex number:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>complex_action {</div>
<div class="line">    std::complex&lt;double&gt; operator()(<span class="keyword">const</span> std::string&amp;, <span class="keyword">const</span> std::string&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">        std::complex&lt;double&gt; result;</div>
<div class="line">        <span class="keyword">auto</span>&amp;&amp; pos = value.find(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span>(pos == std::string::npos) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;invalid complex format given&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        result.real(std::stod(value.substr(0, pos)));</div>
<div class="line">        result.imag(std::stod(value.substr(pos + 1)));</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;complex&quot;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;sets the complex value&quot;</span>,</div>
<div class="line">          opt::custom&lt;std::complex&lt;double&gt;&gt;(complex_action{}) }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="charliteral">&#39;c&#39;</span>)) {</div>
<div class="line">        std::cout &lt;&lt; args.options.get&lt;std::complex&lt;double&gt;&gt;(<span class="charliteral">&#39;c&#39;</span>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When run, it produces the following output:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev -c 1,2</div>
<div class="line">(1,2)</div>
<div class="line">$ ./dev --complex=4,4</div>
<div class="line">(4,4)</div>
<div class="line">$ ./dev --complex=44</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: invalid complex format given</div>
</div><!-- fragment --></div><p>This example shows how to parse an enum:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum class</span> game {</div>
<div class="line">    rock, paper, scissors</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>game_action {</div>
<div class="line">    game operator()(<span class="keyword">const</span> std::string&amp;, <span class="keyword">const</span> std::string&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span>(value == <span class="stringliteral">&quot;rock&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> game::rock;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(value == <span class="stringliteral">&quot;paper&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> game::paper;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(value == <span class="stringliteral">&quot;scissors&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> game::scissors;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;invalid enum value&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;game&quot;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="stringliteral">&quot;sets an enum value&quot;</span>, opt::custom&lt;game&gt;(game_action{}) }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span>&amp;&amp; args = parser.parse(argv, argv + argc);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(args.options.is_active(<span class="charliteral">&#39;g&#39;</span>)) {</div>
<div class="line">        <span class="keywordflow">switch</span>(args.options.get&lt;game&gt;(<span class="charliteral">&#39;g&#39;</span>)) {</div>
<div class="line">        <span class="keywordflow">case</span> game::rock:</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;rock\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> game::scissors:</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;scissors\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> game::paper:</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;paper\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And of course, the output when running:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev --game=rock</div>
<div class="line">rock</div>
<div class="line">$ ./dev --game scissors</div>
<div class="line">scissors</div>
<div class="line">$ ./dev -g paper</div>
<div class="line">paper</div>
<div class="line">$ ./dev -g=test</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line">./dev: error: invalid <span class="keyword">enum</span> value</div>
</div><!-- fragment --></div><h2><a class="anchor" id="custom_eh_and_f"></a>
Custom Error Handling and Formatting</h2>
<p>The optparse module provides a sensible default for handling errors and to format the help message. The default was carefully picked to be consistent with a lot of the tools currently available on Linux. Sometimes however, a little more flexibility and control is needed to print things just the way you want them.</p>
<h3><a class="anchor" id="custom_eh"></a>
Custom Error Handling</h3>
<p>The <code>parse</code> member function of <code>option_parser</code> has some reasonable default error handling mechanisms in place to make the code easier to read. However, if for some reason you want to handle the errors yourself, another member function is provided that does absolutely no error handling named <code>raw_parse</code>. The <code>parse</code> member function also checks for required arguments not being present, which has to be checked through a different member function called <code>notify</code>.</p>
<p>The following example shows how to handle errors using <code>raw_pars</code> and a try-catch block. Note that all errors are derived from <code>optparse::error</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="stringliteral">&quot;required&quot;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;a required option&quot;</span>, opt::constant(<span class="keyword">true</span>), opt::trait::required }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        parser.raw_parse(argv, argv + argc);</div>
<div class="line">        parser.notify();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> opt::missing_required_option&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;You missed the option &quot;</span> &lt;&lt; e.option_name &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> opt::error&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; e.program_name &lt;&lt; <span class="stringliteral">&quot;: unexpected error: &quot;</span> &lt;&lt; e.error_string &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running it leads to the following output:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev</div>
<div class="line">You missed the option --required</div>
<div class="line">$ ./dev --required</div>
<div class="line">$ ./dev --required=<span class="keyword">true</span></div>
<div class="line">./dev: unexpected error: option <span class="stringliteral">&#39;--required&#39;</span> does not take a value</div>
</div><!-- fragment --></div><h3><a class="anchor" id="custom_format"></a>
Custom Formatting</h3>
<p>The default behaviour of the <code>--help</code> message relies on the default implementation of the class <code>optparse::formatter</code>. The formatter class takes care of the formatting of the usage, epilogue, and description messages. Along with that, it also handles the subcommand list and the pretty printing of the currently active <code>option_set</code>. The following example changes the the option formatting.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/optparse.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>opt = gears::optparse;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_formatter : <span class="keyword">public</span> opt::formatter {</div>
<div class="line">    std::string options(<span class="keyword">const</span> opt::option_set&amp; opts)<span class="keyword"> override </span>{</div>
<div class="line">        std::string result = <span class="stringliteral">&quot;options:\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp;&amp; opt : opts) {</div>
<div class="line">            result.append(4, <span class="charliteral">&#39; &#39;</span>).append(1, <span class="charliteral">&#39;-&#39;</span>).append(1, opt.alias);</div>
<div class="line">            result.push_back(<span class="charliteral">&#39;\t&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">        result.push_back(<span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    opt::option_parser parser = {</div>
<div class="line">        { <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;The first option&quot;</span> },</div>
<div class="line">        { <span class="charliteral">&#39;b&#39;</span>, <span class="stringliteral">&quot;The second option&quot;</span> },</div>
<div class="line">        { <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;The third option&quot;</span> }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    parser.help_formatter(my_formatter{});</div>
<div class="line">    parser.parse(argv, argv + argc);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running the code leads to the following help output:</p>
<div class="cmd"><div class="fragment"><div class="line">$ ./dev --help</div>
<div class="line">usage: ./dev [options...]</div>
<div class="line"></div>
<div class="line">options:</div>
<div class="line">    -h      -a      -b      -c</div>
</div><!-- fragment --></div> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
        Copyright Â© Danny Y. Documentation generated by <a href="http://www.doxygen.org/index.html">Doxygen</a>
    </li>
  </ul>
</div>
</body>
</html>
