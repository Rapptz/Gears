<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Gears: gears::container::static_vector&lt; T, N &gt; Struct Template Reference</title>
<title>gears::container::static_vector&lt; T, N &gt; Struct Template Reference</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="index.html"><img alt="Logo" src="gears.png"/></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgears_1_1container_1_1static__vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structgears_1_1container_1_1static__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gears::container::static_vector&lt; T, N &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__container.html">Container module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A vector with a static size.  
 <a href="structgears_1_1container_1_1static__vector.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17c585498f45b8eab624b5db21337854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c585498f45b8eab624b5db21337854"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a17c585498f45b8eab624b5db21337854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabefd628c04d7c5170d86d684eca5f19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabefd628c04d7c5170d86d684eca5f19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = size_t</td></tr>
<tr class="separator:aabefd628c04d7c5170d86d684eca5f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f43563214d4b9e626d36b07758d533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44f43563214d4b9e626d36b07758d533"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = ptrdiff_t</td></tr>
<tr class="separator:a44f43563214d4b9e626d36b07758d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b692193d5ab849355a72ba6dbc414a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6b692193d5ab849355a72ba6dbc414a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:ae6b692193d5ab849355a72ba6dbc414a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18171ee003a8098a04d49e9c5a7969b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18171ee003a8098a04d49e9c5a7969b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const T &amp;</td></tr>
<tr class="separator:a18171ee003a8098a04d49e9c5a7969b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eec3d30366a3abea3ad43cc5cc8da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8eec3d30366a3abea3ad43cc5cc8da5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:ae8eec3d30366a3abea3ad43cc5cc8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa442ed7f8680160234098739d209f06a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa442ed7f8680160234098739d209f06a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:aa442ed7f8680160234098739d209f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccfd44ff0f431e3fe30e3673cebebd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acccfd44ff0f431e3fe30e3673cebebd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = T *</td></tr>
<tr class="separator:acccfd44ff0f431e3fe30e3673cebebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901b010e91bd9be43c2bee407ab50c85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a901b010e91bd9be43c2bee407ab50c85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const T *</td></tr>
<tr class="separator:a901b010e91bd9be43c2bee407ab50c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f855450b6c9ad4ab7b19d5328c6649"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f855450b6c9ad4ab7b19d5328c6649"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; iterator &gt;</td></tr>
<tr class="separator:a54f855450b6c9ad4ab7b19d5328c6649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2aba5e587622da1a6877c6f7199e39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea2aba5e587622da1a6877c6f7199e39"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; const_iterator &gt;</td></tr>
<tr class="separator:aea2aba5e587622da1a6877c6f7199e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa598ec416bbcfdd52d68e0d2e368d847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa598ec416bbcfdd52d68e0d2e368d847"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#aa598ec416bbcfdd52d68e0d2e368d847">static_vector</a> () noexcept=default</td></tr>
<tr class="memdesc:aa598ec416bbcfdd52d68e0d2e368d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static vector of size 0. <br/></td></tr>
<tr class="separator:aa598ec416bbcfdd52d68e0d2e368d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777735069ffa32e2cfa1dcc64c17c2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a777735069ffa32e2cfa1dcc64c17c2e1">static_vector</a> (std::initializer_list&lt; T &gt; l)</td></tr>
<tr class="memdesc:a777735069ffa32e2cfa1dcc64c17c2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a static vector from an initializer list.  <a href="#a777735069ffa32e2cfa1dcc64c17c2e1">More...</a><br/></td></tr>
<tr class="separator:a777735069ffa32e2cfa1dcc64c17c2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2ad141ff4bc365c017a39c2d23034"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#ac5b2ad141ff4bc365c017a39c2d23034">static_vector</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:ac5b2ad141ff4bc365c017a39c2d23034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a static vector with count of values.  <a href="#ac5b2ad141ff4bc365c017a39c2d23034">More...</a><br/></td></tr>
<tr class="separator:ac5b2ad141ff4bc365c017a39c2d23034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cf572bd3e132d9347dfc5f5b2512ee"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a23cf572bd3e132d9347dfc5f5b2512ee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a23cf572bd3e132d9347dfc5f5b2512ee">static_vector</a> (ForwardIt first, ForwardIt last)</td></tr>
<tr class="memdesc:a23cf572bd3e132d9347dfc5f5b2512ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a static vector from two iterators.  <a href="#a23cf572bd3e132d9347dfc5f5b2512ee">More...</a><br/></td></tr>
<tr class="separator:a23cf572bd3e132d9347dfc5f5b2512ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5180894828c6991dc36320ced14b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17a5180894828c6991dc36320ced14b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a17a5180894828c6991dc36320ced14b3">static_vector</a> (const <a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;other)</td></tr>
<tr class="memdesc:a17a5180894828c6991dc36320ced14b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a17a5180894828c6991dc36320ced14b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d76b49a84c64966b95b5622e45cf6e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d76b49a84c64966b95b5622e45cf6e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a3d76b49a84c64966b95b5622e45cf6e4">static_vector</a> (<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3d76b49a84c64966b95b5622e45cf6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:a3d76b49a84c64966b95b5622e45cf6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab501d314b030dd314f6abf6899052686"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab501d314b030dd314f6abf6899052686"></a>
<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#ab501d314b030dd314f6abf6899052686">operator=</a> (const <a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;other)</td></tr>
<tr class="memdesc:ab501d314b030dd314f6abf6899052686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br/></td></tr>
<tr class="separator:ab501d314b030dd314f6abf6899052686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67bfdee5a4fe3cc43e3b81fa1b9bdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f67bfdee5a4fe3cc43e3b81fa1b9bdf"></a>
<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a6f67bfdee5a4fe3cc43e3b81fa1b9bdf">operator=</a> (<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a6f67bfdee5a4fe3cc43e3b81fa1b9bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br/></td></tr>
<tr class="separator:a6f67bfdee5a4fe3cc43e3b81fa1b9bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac7f7cf9ce5d6c478ebc8e83f940ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a96ac7f7cf9ce5d6c478ebc8e83f940ae">operator=</a> (std::initializer_list&lt; T &gt; l)</td></tr>
<tr class="memdesc:a96ac7f7cf9ce5d6c478ebc8e83f940ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value of an initializer list to the static vector.  <a href="#a96ac7f7cf9ce5d6c478ebc8e83f940ae">More...</a><br/></td></tr>
<tr class="separator:a96ac7f7cf9ce5d6c478ebc8e83f940ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e9b4030634e9761d56598a524ecc3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21e9b4030634e9761d56598a524ecc3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a21e9b4030634e9761d56598a524ecc3f">~static_vector</a> ()</td></tr>
<tr class="memdesc:a21e9b4030634e9761d56598a524ecc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a21e9b4030634e9761d56598a524ecc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d8900e6b74bfd5fbee8c7de456e801"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a68d8900e6b74bfd5fbee8c7de456e801">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a68d8900e6b74bfd5fbee8c7de456e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container is empty.  <a href="#a68d8900e6b74bfd5fbee8c7de456e801">More...</a><br/></td></tr>
<tr class="separator:a68d8900e6b74bfd5fbee8c7de456e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4764f3dd5da8b820c5739fa10e0737"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737">size</a> () const noexcept</td></tr>
<tr class="memdesc:a4c4764f3dd5da8b820c5739fa10e0737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#a4c4764f3dd5da8b820c5739fa10e0737">More...</a><br/></td></tr>
<tr class="separator:a4c4764f3dd5da8b820c5739fa10e0737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b528e5a5a59d966b5405dd92320bf"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#abd1b528e5a5a59d966b5405dd92320bf">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:abd1b528e5a5a59d966b5405dd92320bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements allowed.  <a href="#abd1b528e5a5a59d966b5405dd92320bf">More...</a><br/></td></tr>
<tr class="separator:abd1b528e5a5a59d966b5405dd92320bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce28945cf19104453b9c1895959700"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a29ce28945cf19104453b9c1895959700">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a29ce28945cf19104453b9c1895959700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that can be held in storage.  <a href="#a29ce28945cf19104453b9c1895959700">More...</a><br/></td></tr>
<tr class="separator:a29ce28945cf19104453b9c1895959700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e35775638a79c9cd9f5800d898cf7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a6e35775638a79c9cd9f5800d898cf7c0">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:a6e35775638a79c9cd9f5800d898cf7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element.  <a href="#a6e35775638a79c9cd9f5800d898cf7c0">More...</a><br/></td></tr>
<tr class="separator:a6e35775638a79c9cd9f5800d898cf7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb38c2e1773750ad31f5d4e40becff62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#adb38c2e1773750ad31f5d4e40becff62">clear</a> () noexcept</td></tr>
<tr class="memdesc:adb38c2e1773750ad31f5d4e40becff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements.  <a href="#adb38c2e1773750ad31f5d4e40becff62">More...</a><br/></td></tr>
<tr class="separator:adb38c2e1773750ad31f5d4e40becff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbcf82ac2c3a1cb48d36a3c15776167"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dbcf82ac2c3a1cb48d36a3c15776167"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7dbcf82ac2c3a1cb48d36a3c15776167"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a7dbcf82ac2c3a1cb48d36a3c15776167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9549fd70b0956f0f8c8b53f704f06bdd"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a9549fd70b0956f0f8c8b53f704f06bdd">at</a> (size_type pos) const </td></tr>
<tr class="memdesc:a9549fd70b0956f0f8c8b53f704f06bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an element with bounds checking.  <a href="#a9549fd70b0956f0f8c8b53f704f06bdd">More...</a><br/></td></tr>
<tr class="separator:a9549fd70b0956f0f8c8b53f704f06bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd8d25846f8625dc3b0b7f7627d3ed3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd8d25846f8625dc3b0b7f7627d3ed3"></a>
reference&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type pos)</td></tr>
<tr class="separator:a9bd8d25846f8625dc3b0b7f7627d3ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82b93ee24c66c2eb33a041b067d83761"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a82b93ee24c66c2eb33a041b067d83761">operator[]</a> (size_type pos) const </td></tr>
<tr class="memdesc:a82b93ee24c66c2eb33a041b067d83761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an element without bounds checking.  <a href="#a82b93ee24c66c2eb33a041b067d83761">More...</a><br/></td></tr>
<tr class="separator:a82b93ee24c66c2eb33a041b067d83761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5569149a6ea49ef33fe2a42b0986b74f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5569149a6ea49ef33fe2a42b0986b74f"></a>
reference&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type pos)</td></tr>
<tr class="separator:a5569149a6ea49ef33fe2a42b0986b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f67ff58f08433eb6693e632128e68a0"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a6f67ff58f08433eb6693e632128e68a0">front</a> () const </td></tr>
<tr class="memdesc:a6f67ff58f08433eb6693e632128e68a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the first element.  <a href="#a6f67ff58f08433eb6693e632128e68a0">More...</a><br/></td></tr>
<tr class="separator:a6f67ff58f08433eb6693e632128e68a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add04003220206efc7c98949141b11fee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add04003220206efc7c98949141b11fee"></a>
reference&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> ()</td></tr>
<tr class="separator:add04003220206efc7c98949141b11fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa38def0a9f3c5fcf0751a3ec4030f5d3"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#aa38def0a9f3c5fcf0751a3ec4030f5d3">back</a> () const </td></tr>
<tr class="memdesc:aa38def0a9f3c5fcf0751a3ec4030f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the last element.  <a href="#aa38def0a9f3c5fcf0751a3ec4030f5d3">More...</a><br/></td></tr>
<tr class="separator:aa38def0a9f3c5fcf0751a3ec4030f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982ee52a449fe1269098b03eb8bf081a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982ee52a449fe1269098b03eb8bf081a"></a>
reference&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> ()</td></tr>
<tr class="separator:a982ee52a449fe1269098b03eb8bf081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b3aab311925109db6c16dbc380f42f8"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a4b3aab311925109db6c16dbc380f42f8">data</a> () const </td></tr>
<tr class="memdesc:a4b3aab311925109db6c16dbc380f42f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the pointer to the underlying storage.  <a href="#a4b3aab311925109db6c16dbc380f42f8">More...</a><br/></td></tr>
<tr class="separator:a4b3aab311925109db6c16dbc380f42f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bff900a209a8c067ceea19fbf0e9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14bff900a209a8c067ceea19fbf0e9ab"></a>
pointer&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="separator:a14bff900a209a8c067ceea19fbf0e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3b14b7156aaef765cf6ec56c91dac66b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a3b14b7156aaef765cf6ec56c91dac66b">begin</a> ()</td></tr>
<tr class="memdesc:a3b14b7156aaef765cf6ec56c91dac66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element.  <a href="#a3b14b7156aaef765cf6ec56c91dac66b">More...</a><br/></td></tr>
<tr class="separator:a3b14b7156aaef765cf6ec56c91dac66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b2f006ad3ee870e4b9aeb8fbac21d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63b2f006ad3ee870e4b9aeb8fbac21d"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:ad63b2f006ad3ee870e4b9aeb8fbac21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939407f17b61cd862e3863df8f5b32a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae939407f17b61cd862e3863df8f5b32a"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const </td></tr>
<tr class="separator:ae939407f17b61cd862e3863df8f5b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3a6c8d665902fbfee65788420cd143b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#ab3a6c8d665902fbfee65788420cd143b">end</a> ()</td></tr>
<tr class="memdesc:ab3a6c8d665902fbfee65788420cd143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the one past the end element.  <a href="#ab3a6c8d665902fbfee65788420cd143b">More...</a><br/></td></tr>
<tr class="separator:ab3a6c8d665902fbfee65788420cd143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85acf92a95fe3ab3461db33a33f0bdd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85acf92a95fe3ab3461db33a33f0bdd7"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a85acf92a95fe3ab3461db33a33f0bdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9752eabbdae2992e414f136a5e79975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9752eabbdae2992e414f136a5e79975"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const </td></tr>
<tr class="separator:ae9752eabbdae2992e414f136a5e79975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a25911670bc17a6ce0fb2e1a9265bc4ad"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#a25911670bc17a6ce0fb2e1a9265bc4ad">rbegin</a> ()</td></tr>
<tr class="memdesc:a25911670bc17a6ce0fb2e1a9265bc4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element of the container reversed.  <a href="#a25911670bc17a6ce0fb2e1a9265bc4ad">More...</a><br/></td></tr>
<tr class="separator:a25911670bc17a6ce0fb2e1a9265bc4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c28d1b3e9258508635945a7ec14bdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c28d1b3e9258508635945a7ec14bdf"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const </td></tr>
<tr class="separator:ae3c28d1b3e9258508635945a7ec14bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81a472678deb394a0679dc29a297083"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af81a472678deb394a0679dc29a297083"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const </td></tr>
<tr class="separator:af81a472678deb394a0679dc29a297083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afe63db97e506a5636d992e7b7757cd64"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#afe63db97e506a5636d992e7b7757cd64">rend</a> ()</td></tr>
<tr class="memdesc:afe63db97e506a5636d992e7b7757cd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to following the last element of the container reversed.  <a href="#afe63db97e506a5636d992e7b7757cd64">More...</a><br/></td></tr>
<tr class="separator:afe63db97e506a5636d992e7b7757cd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd6ab99aa552cd8da5be1b6eee695ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bd6ab99aa552cd8da5be1b6eee695ee"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const </td></tr>
<tr class="separator:a5bd6ab99aa552cd8da5be1b6eee695ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4237eb6eb381bb1a5994efa4c6ec7221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4237eb6eb381bb1a5994efa4c6ec7221"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const </td></tr>
<tr class="separator:a4237eb6eb381bb1a5994efa4c6ec7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae8d25f571c9dd0b22eb3452667610db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgears_1_1container_1_1static__vector.html#ae8d25f571c9dd0b22eb3452667610db2">push_back</a> (const_reference value)</td></tr>
<tr class="memdesc:ae8d25f571c9dd0b22eb3452667610db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the end.  <a href="#ae8d25f571c9dd0b22eb3452667610db2">More...</a><br/></td></tr>
<tr class="separator:ae8d25f571c9dd0b22eb3452667610db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee50f393ad5206c8b8a8aa86df13d7f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee50f393ad5206c8b8a8aa86df13d7f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:aee50f393ad5206c8b8a8aa86df13d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, size_t N&gt;<br/>
struct gears::container::static_vector&lt; T, N &gt;</h3>

<p>Implements a vector with a static size. The semantics are nearly equivalent to those of <code>std::vector</code>, except with a static size similar to <code>std::array</code>. When the capacity is exceeded, an exception of type <code>std::out_of_range</code> is typically thrown. This container meets the requirement of Container. Its iterators meet the requirement of MutableRandomAccessIterator. Unlike <code>std::vector</code>, the contents of the array are not dynamically allocated. Rather they are stored in automatic storage and then initialised when requested. That is, the data starts out uninitialised.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gears/container/static_vector.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>gears::container;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>example {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    example(<span class="keywordtype">int</span> x): x(x) {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> print()<span class="keyword"> const </span>{</div>
<div class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="structgears_1_1container_1_1static__vector.html" title="A vector with a static size.">static_vector&lt;example, 10&gt;</a> examples;</div>
<div class="line"></div>
<div class="line">    examples.emplace_back(10);</div>
<div class="line">    examples.emplace_back(20);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = examples.<a class="code" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737" title="Returns the number of elements in the container.">size</a>(); i &lt; examples.<a class="code" href="structgears_1_1container_1_1static__vector.html#abd1b528e5a5a59d966b5405dd92320bf" title="Returns the maximum number of elements allowed.">max_size</a>(); ++i) {</div>
<div class="line">        examples.emplace_back(10 + i * 10);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp;&amp; ex : examples) {</div>
<div class="line">        ex.print();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output: </p>
<pre>
10 20 30 40 50 60 70 80 90 100
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to hold. </td></tr>
    <tr><td class="paramname">N</td><td>Maximum capacity of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00090">90</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a777735069ffa32e2cfa1dcc64c17c2e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a static vector from an initializer list. If the length of the initializer list is too large, then <code>std::out_of_range</code> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the length of initializer list is too large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Initializer list to construct with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in l.size() </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00138">138</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b2ad141ff4bc365c017a39c2d23034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a static vector with count of values. If the count provided is too large for the static vector then an exception is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the count is too large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements to initialise. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialise with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in count. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00159">159</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23cf572bd3e132d9347dfc5f5b2512ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::<a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a> </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a static vector from two iterators. If the distance between the two iterators is too large, then an exception is thrown. Note that this constructor expects ForwardIterators, which means multiple passes are meant to be allowed (i.e. no <code>std::istream_iterator</code> or anything similar). The behaviour is undefined if <code>first</code> cannot reach <code>last</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the distance between the iterators is too large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The iterator representing the beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The iterator representing the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in <code>std::distance(first, last)</code>. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00184">184</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9549fd70b0956f0f8c8b53f704f06bdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accesses an element with bounds checking. If the index is out of bounds, an exception is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown if position is out of bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00273">273</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa38def0a9f3c5fcf0751a3ec4030f5d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accesses the last element. If the static vector is empty, then the behaviour is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00331">331</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b14b7156aaef765cf6ec56c91dac66b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first element. If the container is empty, the iterator is equal to <a class="el" href="structgears_1_1container_1_1static__vector.html#ab3a6c8d665902fbfee65788420cd143b" title="Returns an iterator pointing to the one past the end element.">end()</a>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00368">368</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29ce28945cf19104453b9c1895959700"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements that can be held in storage. This just delegates the return to the static capacity provided.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements that can be held in storage. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00493">493</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb38c2e1773750ad31f5d4e40becff62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements of the container. All iterators and references are invalidated.</p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in <a class="el" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737" title="Returns the number of elements in the container.">size</a> </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00517">517</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3aab311925109db6c16dbc380f42f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the pointer to the underlying storage. If the container is empty, the pointer is still valid. The pointer returned is in the range of [data(), data() + <a class="el" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737" title="Returns the number of elements in the container.">size()</a>].</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying storage. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00350">350</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68d8900e6b74bfd5fbee8c7de456e801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the container is empty. That is, <a class="el" href="structgears_1_1container_1_1static__vector.html#a3b14b7156aaef765cf6ec56c91dac66b" title="Returns an iterator pointing to the first element.">begin</a> == <a class="el" href="structgears_1_1container_1_1static__vector.html#ab3a6c8d665902fbfee65788420cd143b" title="Returns an iterator pointing to the one past the end element.">end</a> and <a class="el" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737" title="Returns the number of elements in the container.">size</a> == 0.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if empty, <code>false</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00457">457</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3a6c8d665902fbfee65788420cd143b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the one past the end element. If the container is empty, the iterator is equal to <a class="el" href="structgears_1_1container_1_1static__vector.html#a3b14b7156aaef765cf6ec56c91dac66b" title="Returns an iterator pointing to the first element.">begin()</a>. It is undefined behaviour to dereference this iterator.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the one past the end element. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00391">391</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f67ff58f08433eb6693e632128e68a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accesses the first element. If the static vector is empty, then the behaviour is undefined.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00313">313</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd1b528e5a5a59d966b5405dd92320bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of elements allowed. This just delegates the return to the static capacity provided.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements allowed. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00481">481</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96ac7f7cf9ce5d6c478ebc8e83f940ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgears_1_1container_1_1static__vector.html">static_vector</a>&amp; <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns the value of an initializer list to the static vector. If the length of the initializer list is too large, then <code>std::out_of_range</code> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the initializer list is too large. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The initializer list to construct with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in l.size() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the the static vector. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00244">244</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82b93ee24c66c2eb33a041b067d83761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accesses an element without bounds checking. The behaviour is undefined if the position is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structgears_1_1container_1_1static__vector.html#a9549fd70b0956f0f8c8b53f704f06bdd" title="Accesses an element with bounds checking.">at</a> </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00294">294</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e35775638a79c9cd9f5800d898cf7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the last element of the container. No iterators or references are invalidated except for <a class="el" href="structgears_1_1container_1_1static__vector.html#ab3a6c8d665902fbfee65788420cd143b" title="Returns an iterator pointing to the one past the end element.">end</a> and <a class="el" href="structgears_1_1container_1_1static__vector.html#aa38def0a9f3c5fcf0751a3ec4030f5d3" title="Accesses the last element.">back</a>. The behaviour is undefined if the container is empty.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00505">505</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8d25f571c9dd0b22eb3452667610db2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an element at the end of the container. If <a class="el" href="structgears_1_1container_1_1static__vector.html#a4c4764f3dd5da8b820c5739fa10e0737" title="Returns the number of elements in the container.">size</a> == <a class="el" href="structgears_1_1container_1_1static__vector.html#abd1b528e5a5a59d966b5405dd92320bf" title="Returns the maximum number of elements allowed.">max_size</a> then an exception is thrown. No iterators or references are invalidated. The move constructor is only called if it is declared <code>noexcept</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown if no more elements can be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00536">536</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25911670bc17a6ce0fb2e1a9265bc4ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first element of the container reversed. Essentially, this returns an iterator pointing to the last element of the container.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element of the reversed container. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00413">413</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe63db97e506a5636d992e7b7757cd64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to following the last element of the container reversed. This iterator acts as a sentinel value, attempting to dereference it results in undefined behaviour.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to following the last element of the reversed container. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00436">436</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4764f3dd5da8b820c5739fa10e0737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structgears_1_1container_1_1static__vector.html">gears::container::static_vector</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the container. This is the equivalent of calling <code>std::distance(<a class="el" href="structgears_1_1container_1_1static__vector.html#a3b14b7156aaef765cf6ec56c91dac66b" title="Returns an iterator pointing to the first element.">begin()</a>, <a class="el" href="structgears_1_1container_1_1static__vector.html#ab3a6c8d665902fbfee65788420cd143b" title="Returns an iterator pointing to the one past the end element.">end()</a>)</code>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Constant </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="static__vector_8hpp_source.html#l00469">469</a> of file <a class="el" href="static__vector_8hpp_source.html">static_vector.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
        Copyright  Danny Y. Documentation generated by <a href="http://www.doxygen.org/index.html">Doxygen</a>
    </li>
  </ul>
</div>
</body>
</html>
